# -*- coding: utf-8 -*-
"""MMPOSe Detection & Clinical thresholder .ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1In5lCJGry5IJYe_3jWb8kNfFBfPdGIU4

MMPOSE Detection
"""

# Commented out IPython magic to ensure Python compatibility.
# install MMEngine, MMCV and MMDetection using MIM
# %pip install -U openmim

# Commented out IPython magic to ensure Python compatibility.
!mim install mmcv==2.1.0
# for better Colab compatibility, install xtcocotools from source
# %pip install git+https://github.com/jin-s13/xtcocoapi

# Commented out IPython magic to ensure Python compatibility.
!git clone https://github.com/open-mmlab/mmpose.git
# The master branch is version 1.x
# %cd mmpose
# %pip install -r requirements.txt
# %pip install -v -e .

# Install MMDetection, MMPose, and MMEgine
!mim install mmdet
!mim install mmpose
!mim install mmengine

import os
os.kill(os.getpid(), 9)

import mmcv
from mmcv import imread
import mmengine
from mmengine.registry import init_default_scope
import numpy as np

from mmpose.apis import inference_topdown
from mmpose.apis import init_model as init_pose_estimator
from mmpose.evaluation.functional import nms
from mmpose.registry import VISUALIZERS
from mmpose.structures import merge_data_samples

try:
    from mmdet.apis import inference_detector, init_detector
    has_mmdet = True
except (ImportError, ModuleNotFoundError):
    has_mmdet = False

local_runtime = False

try:
    from google.colab.patches import cv2_imshow  # for image visualization in colab
except:
    local_runtime = True

# Use CPU for inference
device = 'cpu'

# File paths
img = '/content/mmpose/tests/data/coco/000000197388.jpg'
pose_config = '/content/mmpose/configs/body_2d_keypoint/topdown_heatmap/coco/td-hm_hrnet-w32_8xb64-210e_coco-256x192.py'
pose_checkpoint = 'https://download.openmmlab.com/mmpose/top_down/hrnet/hrnet_w32_coco_256x192-c78dce93_20200708.pth'
det_config = '/content/mmpose/demo/mmdetection_cfg/faster_rcnn_r50_fpn_coco.py'
det_checkpoint = 'https://download.openmmlab.com/mmdetection/v2.0/faster_rcnn/faster_rcnn_r50_fpn_1x_coco/faster_rcnn_r50_fpn_1x_coco_20200130-047c8118.pth'

cfg_options = dict(model=dict(test_cfg=dict(output_heatmaps=True)))

# Build the detector
detector = init_detector(
    det_config,
    det_checkpoint,
    device=device
)

# Build the pose estimator
pose_estimator = init_pose_estimator(
    pose_config,
    pose_checkpoint,
    device=device,
    cfg_options=cfg_options
)

# Initialize the visualizer
pose_estimator.cfg.visualizer.radius = 3
pose_estimator.cfg.visualizer.line_width = 1
visualizer = VISUALIZERS.build(pose_estimator.cfg.visualizer)
visualizer.set_dataset_meta(pose_estimator.dataset_meta)

import os
import csv
import numpy as np
import mmcv
from mmdet.apis import inference_detector
#from mmpose.apis import inference_topdown, merge_data_samples
#from mmdet.registry import init_default_scope
#from mmdet.apis.detectors import nms

# Folder containing images
image_folder = '/content'
output_csv = '/content/keypoints_all_images.csv'

# Function to process one image and extract keypoints
def process_image(img_path, detector, pose_estimator):
    # Predict bounding boxes
    scope = detector.cfg.get('default_scope', 'mmdet')
    if scope is not None:
        init_default_scope(scope)
    detect_result = inference_detector(detector, img_path)
    pred_instance = detect_result.pred_instances.cpu().numpy()
    bboxes = np.concatenate(
        (pred_instance.bboxes, pred_instance.scores[:, None]), axis=1)
    bboxes = bboxes[np.logical_and(pred_instance.labels == 0,
                                   pred_instance.scores > 0.3)]
    bboxes = bboxes[nms(bboxes, 0.3)][:, :4]

    # Extract image name
    image_name = os.path.basename(img_path)

    # Predict keypoints
    pose_results = inference_topdown(pose_estimator, img_path, bboxes)

    # Extract keypoints' coordinates
    keypoints_list = []
    for person_result in pose_results:
        if hasattr(person_result.pred_instances, 'keypoints'):
            keypoints = person_result.pred_instances.keypoints[0]  # Get first person's keypoints
            keypoints_flat = [coord for kp in keypoints for coord in kp]  # Flatten (x, y)
            keypoints_list.append([image_name] + keypoints_flat)
        else:
            print(f"No keypoints found for image: {image_name}")

    return keypoints_list

# Function to process all images in a folder
def process_folder(folder_path, detector, pose_estimator, output_csv):
    all_keypoints = []
    header = None

    for img_file in os.listdir(folder_path):
        img_path = os.path.join(folder_path, img_file)
        if img_file.lower().endswith(('.JPG', '.jpg', '.png')):
            print(f"Processing {img_file}...")
            keypoints = process_image(img_path, detector, pose_estimator)
            all_keypoints.extend(keypoints)

            # Prepare header dynamically based on number of keypoints
            if header is None and len(keypoints) > 0:
                num_keypoints = (len(keypoints[0]) - 1) // 2  # Exclude image name
                header = ['Image_Name'] + ['Keypoint_' + str(i + 1) for i in range(num_keypoints * 2)]

    # Save to CSV
    if all_keypoints:
        with open(output_csv, mode='w', newline='') as file:
            writer = csv.writer(file)
            writer.writerow(header)  # Write the header
            writer.writerows(all_keypoints)  # Write all keypoints
        print(f"Keypoints saved to {output_csv}")
    else:
        print("No keypoints found in the folder.")

# Run the script
process_folder(image_folder, detector, pose_estimator, output_csv)

"""labeling with Clinical thresholds"""

import numpy as np
import pandas as pd
import math

class PostureDetector:
    def __init__(self):
        # Clinical thresholds (adjust based on medical guidelines and scale)
        self.thresholds = {
            'cobb_angle': 10,        # Degrees for scoliosis
            'kyphosis_angle': 50,    # Normal thoracic curvature: 20-45°
            'lordosis_angle': 40,    # Normal lumbar curvature: 30-35°
            'head_shift_ratio': 0.15,# Ratio of head position to shoulder width
            'hip_tilt': 5,           # Degrees
            'shoulder_tilt': 5,      # Degrees
            'knee_gap_ratio': 1.5,   # Genu valgum threshold
            'knee_gap_min': 0.5,     # Genu varum threshold
            'foot_angle': 15,        # Degrees for toe-out
            'neck_tilt': 10          # Degrees for torticollis
        }

        # Keypoint mapping (adapt to your CSV column names)
        self.keypoint_map = {
            'head_top': ('Keypoint_1', 'Keypoint_2'),
            'left_ear': ('Keypoint_3', 'Keypoint_4'),
            'right_ear': ('Keypoint_5', 'Keypoint_6'),
            'left_shoulder': ('Keypoint_7', 'Keypoint_8'),
            'right_shoulder': ('Keypoint_9', 'Keypoint_10'),
            'left_hip': ('Keypoint_11', 'Keypoint_12'),
            'right_hip': ('Keypoint_13', 'Keypoint_14'),
            'left_knee': ('Keypoint_15', 'Keypoint_16'),
            'right_knee': ('Keypoint_17', 'Keypoint_18'),
            'left_ankle': ('Keypoint_19', 'Keypoint_20'),
            'right_ankle': ('Keypoint_21', 'Keypoint_22'),
            'left_heel': ('Keypoint_23', 'Keypoint_24'),
            'right_heel': ('Keypoint_25', 'Keypoint_26'),
            'left_toe': ('Keypoint_27', 'Keypoint_28'),
            'right_toe': ('Keypoint_29', 'Keypoint_30'),
            'c7_vertebra': ('Keypoint_31', 'Keypoint_32'),
            'l5_vertebra': ('Keypoint_33', 'Keypoint_34')
        }

    def detect_from_csv(self, csv_path, view_type):
        try:
            keypoints = self._load_keypoints(csv_path)
            self._verify_keypoints(keypoints)

            measurements = {}
            measurements.update(self._analyze_spinal(keypoints, view_type))
            measurements.update(self._analyze_limbs(keypoints, view_type))
            measurements.update(self._analyze_head_neck(keypoints, view_type))
            measurements.update(self._analyze_alignment(keypoints, view_type))

            return self._interpret_results(measurements, view_type)

        except KeyError as e:
            print(f"Missing keypoint column: {e}")
            return {'error': str(e)}
        except Exception as e:
            print(f"Analysis error: {str(e)}")
            return {'error': str(e)}

    def _load_keypoints(self, csv_path):
        """Load and preprocess keypoints from CSV"""
        df = pd.read_csv(csv_path)
        return {col: float(df[col].iloc[0]) for col in df.columns if col != 'Image_Name'}

    def _verify_keypoints(self, kp):
        """Ensure all required keypoints are present"""
        for landmark in self.keypoint_map.values():
            for coord in landmark:
                if coord not in kp:
                    raise KeyError(f"Missing keypoint: {coord}")

    def _get_point(self, kp, landmark_name):
        """Get (x,y) coordinates for a named landmark"""
        x_col, y_col = self.keypoint_map[landmark_name]
        return (kp[x_col], kp[y_col])

    def _calculate_angle(self, a, b, c):
        """Calculate angle at point b between points a-b-c in degrees"""
        ba = np.array(a) - np.array(b)
        bc = np.array(c) - np.array(b)

        cosine_angle = np.dot(ba, bc) / (np.linalg.norm(ba) * np.linalg.norm(bc))
        return np.degrees(np.arccos(np.clip(cosine_angle, -1.0, 1.0)))

    def _analyze_spinal(self, kp, view):
        """Analyze spinal deformities based on view"""
        measurements = {}

        if view in ['front', 'back']:
            # Scoliosis analysis using shoulder-hip alignment
            left_shoulder = self._get_point(kp, 'left_shoulder')
            right_shoulder = self._get_point(kp, 'right_shoulder')
            left_hip = self._get_point(kp, 'left_hip')
            right_hip = self._get_point(kp, 'right_hip')

            shoulder_tilt = self._calculate_angle(
                left_shoulder,
                ((left_shoulder[0]+right_shoulder[0])/2,
                 (left_shoulder[1]+right_shoulder[1])/2),
                right_shoulder
            )

            hip_tilt = self._calculate_angle(
                left_hip,
                ((left_hip[0]+right_hip[0])/2,
                 (left_hip[1]+right_hip[1])/2),
                right_hip
            )

            measurements['cobb_angle'] = abs(shoulder_tilt - hip_tilt)

        if view == 'side':
            # Kyphosis/Lordosis analysis
            c7 = self._get_point(kp, 'c7_vertebra')
            t6 = self._get_point(kp, 'left_shoulder')  # Approximation
            l1 = self._get_point(kp, 'right_hip')      # Approximation
            l5 = self._get_point(kp, 'l5_vertebra')

            measurements['kyphosis_angle'] = self._calculate_angle(c7, t6, l1)
            measurements['lordosis_angle'] = self._calculate_angle(t6, l1, l5)
            measurements['flatback_angle'] = measurements['lordosis_angle']

        return measurements

    def _analyze_limbs(self, kp, view):
        """Analyze lower limb deformities"""
        measurements = {}

        if view == 'front':
            # Genu valgum/varum analysis
            left_knee = self._get_point(kp, 'left_knee')
            right_knee = self._get_point(kp, 'right_knee')
            left_ankle = self._get_point(kp, 'left_ankle')
            right_ankle = self._get_point(kp, 'right_ankle')

            knee_distance = abs(left_knee[0] - right_knee[0])
            ankle_distance = abs(left_ankle[0] - right_ankle[0])
            measurements['knee_gap_ratio'] = ankle_distance / knee_distance if knee_distance != 0 else 0

            # Toe-out angle
            left_foot_angle = self._calculate_angle(
                self._get_point(kp, 'left_knee'),
                self._get_point(kp, 'left_ankle'),
                self._get_point(kp, 'left_toe')
            )
            right_foot_angle = self._calculate_angle(
                self._get_point(kp, 'right_knee'),
                self._get_point(kp, 'right_ankle'),
                self._get_point(kp, 'right_toe')
            )
            measurements['foot_angle'] = max(left_foot_angle, right_foot_angle)

        return measurements

    def _analyze_head_neck(self, kp, view):
        """Analyze head and neck posture"""
        measurements = {}

        if view == 'side':
            # Forward head measurement
            ear = self._get_point(kp, 'left_ear')
            shoulder = self._get_point(kp, 'left_shoulder')
            head_shift = ear[0] - shoulder[0]
            shoulder_width = abs(self._get_point(kp, 'left_shoulder')[0] -
                                self._get_point(kp, 'right_shoulder')[0])
            measurements['head_shift_ratio'] = abs(head_shift)/shoulder_width if shoulder_width != 0 else 0

        # Neck tilt for torticollis
        head_top = self._get_point(kp, 'head_top')
        c7 = self._get_point(kp, 'c7_vertebra')
        neck_tilt = math.degrees(math.atan2(
            c7[1] - head_top[1],
            c7[0] - head_top[0]
        ))
        measurements['neck_tilt'] = abs(neck_tilt)

        return measurements

    def _analyze_alignment(self, kp, view):
        """Analyze shoulder and hip alignment"""
        measurements = {}

        # Shoulder tilt
        left_shoulder = self._get_point(kp, 'left_shoulder')
        right_shoulder = self._get_point(kp, 'right_shoulder')
        measurements['shoulder_tilt'] = math.degrees(math.atan2(
            right_shoulder[1] - left_shoulder[1],
            right_shoulder[0] - left_shoulder[0]
        ))

        # Hip tilt
        left_hip = self._get_point(kp, 'left_hip')
        right_hip = self._get_point(kp, 'right_hip')
        measurements['hip_tilt'] = math.degrees(math.atan2(
            right_hip[1] - left_hip[1],
            right_hip[0] - left_hip[0]
        ))

        return measurements

    def _interpret_results(self, measurements, view):
        """Convert measurements to deformity detections"""
        deformities = []
        thresholds = self.thresholds

        # Spinal deformities
        if view in ['front', 'back']:
            if measurements.get('cobb_angle', 0) > thresholds['cobb_angle']:
                deformities.append('scoliosis')

        if  view in ['front', 'side']:
            if measurements.get('kyphosis_angle', 0) > thresholds['kyphosis_angle']:
                deformities.append('kyphosis')
            if measurements.get('lordosis_angle', 0) > thresholds['lordosis_angle']:
                deformities.append('lordosis')
            if measurements.get('flatback_angle', 0) < 25:  # Custom threshold
                deformities.append('flatback')

        # Head/neck
        if  view in ['front', 'side']:
            if measurements.get('head_shift_ratio', 0) > thresholds['head_shift_ratio']:
                deformities.append('forwardhead')
        if measurements.get('neck_tilt', 0) > thresholds['neck_tilt']:
            deformities.append('torticolis')

        # Lower body
        if view == 'front':
            kgr = measurements.get('knee_gap_ratio', 1)
            if kgr > thresholds['knee_gap_ratio']:
                deformities.append('genuvalgum')
            elif kgr < thresholds['knee_gap_min']:
                deformities.append('genuvarum')
            if measurements.get('foot_angle', 0) > thresholds['foot_angle']:
                deformities.append('toeout')

        # Alignment
        if abs(measurements.get('shoulder_tilt', 0)) > thresholds['shoulder_tilt']:
            deformities.append('unevenshoulders')
        if abs(measurements.get('hip_tilt', 0)) > thresholds['hip_tilt']:
            deformities.append('unevenhip')

        # Always check for normal
        if not deformities:
            deformities.append('normal')

        return {
            'deformities': deformities,
            'measurements': measurements,
            'view': view
        }

detector = PostureDetector()

# Front view analysis
front_results = detector.detect_from_csv('/content/keypoints_all_images.csv', 'front')
print("Front View Detections:", front_results['deformities'])


# Side view analysis
#side_results = detector.detect_from_csv('side_view_keypoints.csv', 'side')
#print("Side View Detections:", side_results['deformities'])

# Back view analysis
#back_results = detector.detect_from_csv('back_view_keypoints.csv', 'back')
#print("Back View Detections:", back_results['deformities'])

import numpy as np
import pandas as pd
import math
import os
import re
from sklearn.metrics import classification_report

class PostureDetector:
    def __init__(self):
        # Clinical thresholds
        self.thresholds = {
            'cobb_angle': 10,        # Degrees for scoliosis
            'kyphosis_angle': 50,    # Normal thoracic curvature: 20-45°
            'lordosis_angle': 40,    # Normal lumbar curvature: 30-35°
            'head_shift_ratio': 0.15,# Ratio of head position to shoulder width
            'hip_tilt': 5,           # Degrees
            'shoulder_tilt': 5,      # Degrees
            'knee_gap_ratio': 1.5,   # Genu valgum threshold
            'knee_gap_min': 0.5,     # Genu varum threshold
            'foot_angle': 15,        # Degrees for toe-out
            'neck_tilt': 10          # Degrees for torticollis
        }

        # Keypoint mapping
        self.keypoint_map = {
            'head_top': ('Keypoint_1', 'Keypoint_2'),
            'left_ear': ('Keypoint_3', 'Keypoint_4'),
            'right_ear': ('Keypoint_5', 'Keypoint_6'),
            'left_shoulder': ('Keypoint_7', 'Keypoint_8'),
            'right_shoulder': ('Keypoint_9', 'Keypoint_10'),
            'left_hip': ('Keypoint_11', 'Keypoint_12'),
            'right_hip': ('Keypoint_13', 'Keypoint_14'),
            'left_knee': ('Keypoint_15', 'Keypoint_16'),
            'right_knee': ('Keypoint_17', 'Keypoint_18'),
            'left_ankle': ('Keypoint_19', 'Keypoint_20'),
            'right_ankle': ('Keypoint_21', 'Keypoint_22'),
            'left_heel': ('Keypoint_23', 'Keypoint_24'),
            'right_heel': ('Keypoint_25', 'Keypoint_26'),
            'left_toe': ('Keypoint_27', 'Keypoint_28'),
            'right_toe': ('Keypoint_29', 'Keypoint_30'),
            'c7_vertebra': ('Keypoint_31', 'Keypoint_32'),
            'l5_vertebra': ('Keypoint_33', 'Keypoint_34')
        }

        # List of all keypoint columns
        self.keypoint_columns = [f'Keypoint_{i}' for i in range(1, 35)]

    def detect_single_image(self, kp_dict, view_type='front'):
        """Analyze posture for a single image from keypoint dictionary"""
        try:
            self._verify_keypoints(kp_dict)
            measurements = {}
            measurements.update(self._analyze_spinal(kp_dict, view_type))
            measurements.update(self._analyze_limbs(kp_dict, view_type))
            measurements.update(self._analyze_head_neck(kp_dict, view_type))
            measurements.update(self._analyze_alignment(kp_dict, view_type))
            return self._interpret_results(measurements, view_type)
        except Exception as e:
            print(f"Analysis error: {str(e)}")
            return {'deformities': ['error'], 'measurements': {}, 'view': view_type}

    def _verify_keypoints(self, kp):
        """Ensure all required keypoints are present"""
        for landmark in self.keypoint_map.values():
            for coord in landmark:
                if coord not in kp:
                    raise KeyError(f"Missing keypoint: {coord}")

    def _get_point(self, kp, landmark_name):
        """Get (x,y) coordinates for a named landmark"""
        x_col, y_col = self.keypoint_map[landmark_name]
        return (kp[x_col], kp[y_col])

    def _calculate_angle(self, a, b, c):
        """Calculate angle at point b between points a-b-c in degrees"""
        ba = np.array(a) - np.array(b)
        bc = np.array(c) - np.array(b)

        # Handle zero-length vectors
        norm_ba = np.linalg.norm(ba)
        norm_bc = np.linalg.norm(bc)

        if norm_ba < 1e-6 or norm_bc < 1e-6:
            return 0.0  # Avoid division by zero

        cosine_angle = np.dot(ba, bc) / (norm_ba * norm_bc)
        cosine_angle = np.clip(cosine_angle, -1.0, 1.0)  # Ensure valid range
        return np.degrees(np.arccos(cosine_angle))

    def _analyze_spinal(self, kp, view):
        """Analyze spinal deformities based on view"""
        measurements = {}

        if view in ['front', 'back']:
            # Scoliosis analysis using shoulder-hip alignment
            left_shoulder = self._get_point(kp, 'left_shoulder')
            right_shoulder = self._get_point(kp, 'right_shoulder')
            left_hip = self._get_point(kp, 'left_hip')
            right_hip = self._get_point(kp, 'right_hip')

            shoulder_tilt = self._calculate_angle(
                left_shoulder,
                ((left_shoulder[0]+right_shoulder[0])/2,
                 (left_shoulder[1]+right_shoulder[1])/2),
                right_shoulder
            )

            hip_tilt = self._calculate_angle(
                left_hip,
                ((left_hip[0]+right_hip[0])/2,
                 (left_hip[1]+right_hip[1])/2),
                right_hip
            )

            measurements['cobb_angle'] = abs(shoulder_tilt - hip_tilt)

        if view == 'side':
            # Kyphosis/Lordosis analysis
            c7 = self._get_point(kp, 'c7_vertebra')
            t6 = self._get_point(kp, 'left_shoulder')  # Approximation
            l1 = self._get_point(kp, 'right_hip')      # Approximation
            l5 = self._get_point(kp, 'l5_vertebra')

            measurements['kyphosis_angle'] = self._calculate_angle(c7, t6, l1)
            measurements['lordosis_angle'] = self._calculate_angle(t6, l1, l5)
            measurements['flatback_angle'] = measurements.get('lordosis_angle', 0)

        return measurements

    def _analyze_limbs(self, kp, view):
        """Analyze lower limb deformities"""
        measurements = {}

        if view == 'front':
            # Genu valgum/varum analysis
            left_knee = self._get_point(kp, 'left_knee')
            right_knee = self._get_point(kp, 'right_knee')
            left_ankle = self._get_point(kp, 'left_ankle')
            right_ankle = self._get_point(kp, 'right_ankle')

            knee_distance = abs(left_knee[0] - right_knee[0])
            ankle_distance = abs(left_ankle[0] - right_ankle[0])

            # Handle zero knee distance
            if knee_distance < 1e-6:
                measurements['knee_gap_ratio'] = 0
            else:
                measurements['knee_gap_ratio'] = ankle_distance / knee_distance

            # Toe-out angle
            try:
                left_foot_angle = self._calculate_angle(
                    self._get_point(kp, 'left_knee'),
                    self._get_point(kp, 'left_ankle'),
                    self._get_point(kp, 'left_toe')
                )
                right_foot_angle = self._calculate_angle(
                    self._get_point(kp, 'right_knee'),
                    self._get_point(kp, 'right_ankle'),
                    self._get_point(kp, 'right_toe')
                )
                measurements['foot_angle'] = max(left_foot_angle, right_foot_angle)
            except:
                measurements['foot_angle'] = 0

        return measurements

    def _analyze_head_neck(self, kp, view):
        """Analyze head and neck posture"""
        measurements = {}

        if view == 'side':
            # Forward head measurement
            try:
                ear = self._get_point(kp, 'left_ear')
                shoulder = self._get_point(kp, 'left_shoulder')
                head_shift = ear[0] - shoulder[0]
                shoulder_width = abs(self._get_point(kp, 'left_shoulder')[0] -
                                self._get_point(kp, 'right_shoulder')[0])

                if shoulder_width < 1e-6:
                    measurements['head_shift_ratio'] = 0
                else:
                    measurements['head_shift_ratio'] = abs(head_shift)/shoulder_width
            except:
                measurements['head_shift_ratio'] = 0

        # Neck tilt for torticollis
        try:
            head_top = self._get_point(kp, 'head_top')
            c7 = self._get_point(kp, 'c7_vertebra')
            neck_tilt = math.degrees(math.atan2(
                c7[1] - head_top[1],
                c7[0] - head_top[0]
            ))
            measurements['neck_tilt'] = abs(neck_tilt)
        except:
            measurements['neck_tilt'] = 0

        return measurements

    def _analyze_alignment(self, kp, view):
        """Analyze shoulder and hip alignment"""
        measurements = {}

        # Shoulder tilt
        try:
            left_shoulder = self._get_point(kp, 'left_shoulder')
            right_shoulder = self._get_point(kp, 'right_shoulder')
            measurements['shoulder_tilt'] = math.degrees(math.atan2(
                right_shoulder[1] - left_shoulder[1],
                right_shoulder[0] - left_shoulder[0]
            ))
        except:
            measurements['shoulder_tilt'] = 0

        # Hip tilt
        try:
            left_hip = self._get_point(kp, 'left_hip')
            right_hip = self._get_point(kp, 'right_hip')
            measurements['hip_tilt'] = math.degrees(math.atan2(
                right_hip[1] - left_hip[1],
                right_hip[0] - left_hip[0]
            ))
        except:
            measurements['hip_tilt'] = 0

        return measurements

    def _interpret_results(self, measurements, view):
        """Convert measurements to deformity detections"""
        deformities = []
        thresholds = self.thresholds

        # Spinal deformities
        if view in ['front', 'back']:
            if measurements.get('cobb_angle', 0) > thresholds['cobb_angle']:
                deformities.append('scoliosis')

        if view in ['front', 'side']:
            if measurements.get('kyphosis_angle', 0) > thresholds['kyphosis_angle']:
                deformities.append('kyphosis')
            if measurements.get('lordosis_angle', 0) > thresholds['lordosis_angle']:
                deformities.append('lordosis')
            if measurements.get('flatback_angle', 0) < 25:  # Custom threshold
                deformities.append('flatback')

        # Head/neck
        if view in ['front', 'side']:
            if measurements.get('head_shift_ratio', 0) > thresholds['head_shift_ratio']:
                deformities.append('forwardhead')
        if measurements.get('neck_tilt', 0) > thresholds['neck_tilt']:
            deformities.append('torticolis')

        # Lower body
        if view == 'front':
            kgr = measurements.get('knee_gap_ratio', 1)
            if kgr > thresholds['knee_gap_ratio']:
                deformities.append('genuvalgum')
            elif kgr < thresholds['knee_gap_min']:
                deformities.append('genuvarum')
            if measurements.get('foot_angle', 0) > thresholds['foot_angle']:
                deformities.append('toeout')

        # Alignment
        if abs(measurements.get('shoulder_tilt', 0)) > thresholds['shoulder_tilt']:
            deformities.append('unevenshoulders')
        if abs(measurements.get('hip_tilt', 0)) > thresholds['hip_tilt']:
            deformities.append('unevenhip')

        # Always check for normal
        if not deformities:
            deformities.append('normal')

        return {
            'deformities': deformities,
            'measurements': measurements,
            'view': view
        }

# Define the deformity class order matching your ground truth format
CLASS_ORDER = [
    'scoliosis', 'kyphosis', 'lordosis', 'flatback', 'forwardhead', 'torticolis',
    'genuvalgum', 'genuvarum', 'toeout', 'unevenshoulders', 'unevenhip', 'normal'
]

def normalize_image_name(name):
    """Robust image name normalization with multiple cleaning steps"""
    name = str(name).lower().strip()

    # Remove directory paths if present
    base_name = os.path.basename(name)

    # Remove file extensions
    if '.' in base_name:
        base_name = base_name[:base_name.rindex('.')]

    # Remove common prefixes
    prefixes = ['img_', 'image_', 'photo_', 'pic_', 'snap_', 'capture_']
    for prefix in prefixes:
        if base_name.startswith(prefix):
            base_name = base_name[len(prefix):]

    # Remove non-alphanumeric characters except underscores
    base_name = re.sub(r'[^a-z0-9_]', '', base_name)

    # Extract numbers (fallback if name is complex)
    numbers = re.findall(r'\d+', base_name)
    if numbers:
        return ''.join(numbers)
    return base_name

def load_ground_truth(file_path):
    """Enhanced ground truth loader with flexible parsing"""
    gt_data = []
    with open(file_path, 'r') as f:
        for line in f:
            # Handle different separators
            if '\t' in line:
                parts = line.split('\t')
            elif ',' in line:
                parts = line.split(',')
            else:
                parts = line.split()

            if len(parts) < 2:
                continue

            img_name = parts[0].strip()
            labels_str = parts[1].strip().strip('[]"\'')

            # Extract numeric labels
            labels = []
            for x in labels_str.split(','):
                x = x.strip()
                if x.replace('.', '').isdigit():
                    labels.append(int(float(x)))
                elif x in ['0', '1']:  # Handle 0/1 strings
                    labels.append(int(x))

            # Pad to 12 classes if needed
            if len(labels) < len(CLASS_ORDER):
                labels += [0] * (len(CLASS_ORDER) - len(labels))
            elif len(labels) > len(CLASS_ORDER):
                labels = labels[:len(CLASS_ORDER)]

            gt_data.append((img_name, labels))

    return pd.DataFrame(gt_data, columns=['image_name', 'true_labels'])

def main():
    print("Starting posture detector evaluation...")

    # Initialize detector
    detector = PostureDetector()

    # Load ground truth
    print("Loading ground truth labels...")
    try:
        gt_df = load_ground_truth('/content/Total_datalabels_onehot.csv')
        # Add normalized name column
        gt_df['normalized_name'] = gt_df['image_name'].apply(normalize_image_name)
        print(f"Loaded {len(gt_df)} ground truth records")
        print("Sample ground truth names:")
        print(gt_df[['image_name', 'normalized_name']].head(3))
    except Exception as e:
        print(f"Error loading ground truth: {str(e)}")
        return

    # Load keypoints data
    print("Loading keypoints data...")
    try:
        keypoints_df = pd.read_csv('/content/keypoints_all_images.csv')
        # Add normalized name column
        keypoints_df['normalized_name'] = keypoints_df['Image_Name'].apply(normalize_image_name)
        print(f"Loaded {len(keypoints_df)} keypoint records")
        print("Sample keypoint names:")
        print(keypoints_df[['Image_Name', 'normalized_name']].head(3))
    except Exception as e:
        print(f"Error loading keypoints: {str(e)}")
        return

    # Prepare to collect predictions
    predictions = []
    processed_count = 0
    error_count = 0

    print("\nProcessing images...")
    # Process each image
    for idx, row in keypoints_df.iterrows():
        img_name = row['Image_Name']
        normalized_name = row['normalized_name']
        print(f"Processing {img_name} ({idx+1}/{len(keypoints_df)})")

        # Create keypoint dictionary
        kp_dict = {col: row[col] for col in keypoints_df.columns
                  if col.startswith('Keypoint') or col == 'Image_Name'}

        # Analyze posture using front view
        try:
            result = detector.detect_single_image(kp_dict, 'front')
            deformities = result['deformities']

            # Convert to one-hot vector
            pred_vector = [1 if cls in deformities else 0 for cls in CLASS_ORDER]
            predictions.append((normalized_name, pred_vector))
            processed_count += 1
        except Exception as e:
            print(f"  Error processing {img_name}: {str(e)}")
            predictions.append((normalized_name, [0]*len(CLASS_ORDER)))
            error_count += 1

    print(f"\nProcessing complete. Success: {processed_count}, Errors: {error_count}")

    # Create prediction DataFrame
    pred_df = pd.DataFrame(predictions, columns=['normalized_name', 'pred_labels'])

    # Merge with ground truth using normalized names
    merged_df = pd.merge(
        gt_df,
        pred_df,
        on='normalized_name',
        how='inner'
    )

    # First-level matching diagnostics
    print(f"\nAfter basic matching: {len(merged_df)} records")

    # Fallback matching: extract numbers from names
    if len(merged_df) == 0:
        print("\nTrying fallback matching by numeric IDs...")
        gt_df['numeric_id'] = gt_df['image_name'].apply(lambda x: ''.join(re.findall(r'\d+', str(x))))
        keypoints_df['numeric_id'] = keypoints_df['Image_Name'].apply(lambda x: ''.join(re.findall(r'\d+', str(x))))
        pred_df['numeric_id'] = keypoints_df['numeric_id']  # Align with keypoints

        merged_df = pd.merge(
            gt_df,
            pred_df,
            on='numeric_id',
            how='inner'
        )
        print(f"After numeric matching: {len(merged_df)} records")

    # Final matching attempt: base filename without extension
    if len(merged_df) == 0:
        print("\nTrying fallback matching by base filenames...")
        gt_df['base_name'] = gt_df['image_name'].apply(lambda x: os.path.splitext(os.path.basename(str(x)))[0].lower())
        keypoints_df['base_name'] = keypoints_df['Image_Name'].apply(lambda x: os.path.splitext(os.path.basename(str(x)))[0].lower())
        pred_df['base_name'] = keypoints_df['base_name']  # Align with keypoints

        merged_df = pd.merge(
            gt_df,
            pred_df,
            on='base_name',
            how='inner'
        )
        print(f"After base name matching: {len(merged_df)} records")

    # Final diagnostics
    print(f"\nMerged {len(merged_df)} records for evaluation")

    if len(merged_df) == 0:
        print("\nERROR: No matching records found after multiple attempts.")
        print("Please verify your input files contain the same images.")

        # Show name distribution
        print("\nName comparison:")
        print("Ground truth names:", gt_df['image_name'].head(5).tolist())
        print("Keypoints names:", keypoints_df['Image_Name'].head(5).tolist())

        # Show normalized versions
        print("\nNormalized versions:")
        print("GT Normalized:", gt_df['normalized_name'].head(5).tolist())
        print("KP Normalized:", keypoints_df['normalized_name'].head(5).tolist())

        # Show numeric IDs
        print("\nNumeric IDs:")
        print("GT Numeric:", gt_df['numeric_id'].head(5).tolist())
        print("KP Numeric:", keypoints_df['numeric_id'].head(5).tolist())
        return

    # Prepare true and predicted labels
    y_true = np.array(merged_df['true_labels'].tolist())
    y_pred = np.array(merged_df['pred_labels'].tolist())

    print("\nLabel distribution in true data:")
    print(f"Total samples: {y_true.shape[0]}")
    for i, cls in enumerate(CLASS_ORDER):
        print(f"  {cls:<15}: {np.sum(y_true[:, i])} positive samples")

    print("\nLabel distribution in predictions:")
    for i, cls in enumerate(CLASS_ORDER):
        print(f"  {cls:<15}: {np.sum(y_pred[:, i])} positive samples")

    # Generate classification report
    print("\n" + "="*80)
    print("Posture Detector Performance Evaluation")
    print("="*80)

    try:
        report = classification_report(
            y_true,
            y_pred,
            target_names=CLASS_ORDER,
            zero_division=0
        )
        print(report)
    except Exception as e:
        print(f"Error generating classification report: {str(e)}")
        print("Falling back to per-class metrics...")

        # Manual metrics calculation
        print("\nPer-class metrics:")
        print(f"{'Class':<15} | {'Accuracy':<8} | {'Precision':<8} | {'Recall':<8}")
        print("-" * 45)

        for i, cls in enumerate(CLASS_ORDER):
            true_col = y_true[:, i]
            pred_col = y_pred[:, i]

            # Skip classes with no true positives
            if np.sum(true_col) == 0:
                print(f"{cls:<15} | {'N/A':<8} | {'N/A':<8} | {'N/A':<8}")
                continue

            tp = np.sum((true_col == 1) & (pred_col == 1))
            tn = np.sum((true_col == 0) & (pred_col == 0))
            fp = np.sum((true_col == 0) & (pred_col == 1))
            fn = np.sum((true_col == 1) & (pred_col == 0))

            accuracy = (tp + tn) / (tp + tn + fp + fn) if (tp + tn + fp + fn) > 0 else 0
            precision = tp / (tp + fp) if (tp + fp) > 0 else 0
            recall = tp / (tp + fn) if (tp + fn) > 0 else 0

            print(f"{cls:<15} | {accuracy:.4f}   | {precision:.4f}   | {recall:.4f}")

if __name__ == "__main__":
    main()



"""Mapping on image with angles"""

import cv2
import pandas as pd
import numpy as np
import math

class PostureVisualizer:
    def __init__(self):
        # MMPose keypoint mapping (17 points, 34 coordinates)
        self.keypoint_names = [
            "Nose", "Left_Eye", "Right_Eye", "Left_Ear", "Right_Ear",
            "Left_Shoulder", "Right_Shoulder", "Left_Elbow", "Right_Elbow",
            "Left_Wrist", "Right_Wrist", "Left_Hip", "Right_Hip",
            "Left_Knee", "Right_Knee", "Left_Ankle", "Right_Ankle"
        ]

        # MMPose skeleton connections (0-based indices)
        self.skeleton = [
            (0, 1), (0, 2),    # Head
            (1, 3), (2, 4),    # Ears
            (5, 6), (5, 7), (7, 9),  # Left arm
            (6, 8), (8, 10),   # Right arm
            (11, 12),          # Hips
            (5, 11), (6, 12),  # Shoulder to hip
            (11, 13), (13, 15),# Left leg
            (12, 14), (14, 16) # Right leg
        ]

        # Color scheme
        self.colors = {
            'skeleton': (255, 255, 255),  # White
            'landmark': (0, 255, 0),      # Green
            'normal': (0, 255, 0),        # Green
            'abnormal': (0, 0, 255),      # Red
            'text': (255, 255, 0),        # Cyan
            'angles': (0, 255, 255)       # Yellow
        }

    def visualize_posture(self, image_path, csv_path, output_path):
        # Load image and keypoints
        img = cv2.imread(image_path)
        df = pd.read_csv(csv_path)
        kp = {col: float(df[col].iloc[0]) for col in df.columns if col != 'Image_Name'}

        # Draw keypoints and skeleton
        self._draw_skeleton(img, kp)

        # Perform and visualize alignment analysis
        analysis_results = self._analyze_alignments(img, kp)

        # Save and return results
        cv2.imwrite(output_path, img)
        return img, analysis_results

    def _get_kp(self, kp, index):
        """Get (x,y) coordinates for 0-based keypoint index"""
        x = kp.get(f'Keypoint_{index*2+1}', 0)
        y = kp.get(f'Keypoint_{index*2+2}', 0)
        return (int(x), int(y))

    def _draw_skeleton(self, img, kp):
        # Draw connections first
        for connection in self.skeleton:
            start_idx, end_idx = connection
            start_point = self._get_kp(kp, start_idx)
            end_point = self._get_kp(kp, end_idx)

            if start_point[0] > 0 and start_point[1] > 0 and end_point[0] > 0 and end_point[1] > 0:
                cv2.line(img, start_point, end_point, self.colors['skeleton'], 2)

        # Draw keypoints
        for i in range(17):
            x, y = self._get_kp(kp, i)
            if x > 0 and y > 0:
                cv2.circle(img, (x, y), 5, self.colors['landmark'], -1)
                cv2.putText(img, str(i), (x+5, y-5),
                           cv2.FONT_HERSHEY_SIMPLEX, 0.4, (255,255,255), 1)

    def _analyze_alignments(self, img, kp):
        results = {}

        # Spinal analysis
        results['spinal_curvature'] = self._draw_spinal_analysis(img, kp)

        # Shoulder alignment
        results['shoulder_tilt'] = self._draw_shoulder_analysis(img, kp)

        # Hip alignment
        results['hip_tilt'] = self._draw_hip_analysis(img, kp)

        # Head position
        results['head_shift'] = self._draw_head_analysis(img, kp)

        return results

    def _draw_spinal_analysis(self, img, kp):
        try:
            # Mid-shoulders (5:Left_Shoulder, 6:Right_Shoulder)
            left_shoulder = self._get_kp(kp, 5)
            right_shoulder = self._get_kp(kp, 6)
            mid_shoulder = (
                (left_shoulder[0] + right_shoulder[0]) // 2,
                (left_shoulder[1] + right_shoulder[1]) // 2
            )

            # Mid-hips (11:Left_Hip, 12:Right_Hip)
            left_hip = self._get_kp(kp, 11)
            right_hip = self._get_kp(kp, 12)
            mid_hip = (
                (left_hip[0] + right_hip[0]) // 2,
                (left_hip[1] + right_hip[1]) // 2
            )

            # Draw spinal line
            cv2.line(img, mid_shoulder, mid_hip, self.colors['angles'], 2)

            # Calculate angle deviation from vertical
            delta_x = mid_hip[0] - mid_shoulder[0]
            delta_y = mid_hip[1] - mid_shoulder[1]
            angle = math.degrees(math.atan2(delta_x, delta_y))

            color = self.colors['abnormal'] if abs(angle) > 10 else self.colors['normal']
            cv2.putText(img, f"Spinal Curvature: {abs(angle):.1f}°",
                       (mid_shoulder[0]+10, mid_shoulder[1]+30),
                       cv2.FONT_HERSHEY_SIMPLEX, 0.6, color, 2)
            return angle

        except:
            return 0

    def _draw_shoulder_analysis(self, img, kp):
        try:
            left_shoulder = self._get_kp(kp, 5)
            right_shoulder = self._get_kp(kp, 6)

            # Draw shoulder line
            cv2.line(img, left_shoulder, right_shoulder, self.colors['angles'], 2)

            # Calculate tilt angle
            delta_y = right_shoulder[1] - left_shoulder[1]
            delta_x = right_shoulder[0] - left_shoulder[0]
            angle = math.degrees(math.atan2(delta_y, delta_x))

            color = self.colors['abnormal'] if abs(angle) > 5 else self.colors['normal']
            cv2.putText(img, f"Shoulder Tilt: {angle:.1f}°",
                       ((left_shoulder[0]+right_shoulder[0])//2,
                        (left_shoulder[1]+right_shoulder[1])//2),
                       cv2.FONT_HERSHEY_SIMPLEX, 0.6, color, 2)
            return angle
        except:
            return 0

    def _draw_hip_analysis(self, img, kp):
        try:
            left_hip = self._get_kp(kp, 11)
            right_hip = self._get_kp(kp, 12)

            # Draw hip line
            cv2.line(img, left_hip, right_hip, self.colors['angles'], 2)

            # Calculate tilt angle
            delta_y = right_hip[1] - left_hip[1]
            delta_x = right_hip[0] - left_hip[0]
            angle = math.degrees(math.atan2(delta_y, delta_x))

            color = self.colors['abnormal'] if abs(angle) > 5 else self.colors['normal']
            cv2.putText(img, f"Hip Tilt: {angle:.1f}°",
                       ((left_hip[0]+right_hip[0])//2,
                        (left_hip[1]+right_hip[1])//2),
                       cv2.FONT_HERSHEY_SIMPLEX, 0.6, color, 2)
            return angle
        except:
            return 0

    def _draw_head_analysis(self, img, kp):
        try:
            nose = self._get_kp(kp, 0)
            mid_shoulder = (
                (self._get_kp(kp, 5)[0] + self._get_kp(kp, 6)[0]) // 2,
                (self._get_kp(kp, 5)[1] + self._get_kp(kp, 6)[1]) // 2
            )

            # Draw reference line
            cv2.line(img, (nose[0], mid_shoulder[1]), mid_shoulder,
                    self.colors['angles'], 2)

            # Calculate horizontal shift
            shift = nose[0] - mid_shoulder[0]
            color = self.colors['abnormal'] if abs(shift) > 15 else self.colors['normal']

            cv2.putText(img, f"Head Shift: {shift:.1f}px",
                       (nose[0]+10, nose[1]-10),
                       cv2.FONT_HERSHEY_SIMPLEX, 0.6, color, 2)
            return shift
        except:
            return 0

# Usage Example
if __name__ == "__main__":
    visualizer = PostureVisualizer()

    # Replace with your actual paths
    image_path = "/content/5812437511954353621.jpg"
    csv_path = "/content/keypoints_all_images.csv"
    output_path = "analyzed_image.jpg"

    result_img, analysis = visualizer.visualize_posture(
        image_path, csv_path, output_path
    )
    from google.colab.patches import cv2_imshow
    # Display results
    cv2_imshow(result_img)
    cv2.waitKey(0)
    cv2.destroyAllWindows()

    print("\nPosture Analysis Results:")
    print(f"Spinal Curvature Angle: {analysis['spinal_curvature']:.1f}°")
    print(f"Shoulder Tilt: {analysis['shoulder_tilt']:.1f}°")
    print(f"Hip Tilt: {analysis['hip_tilt']:.1f}°")
    print(f"Head Shift: {analysis['head_shift']:.1f} pixels")





! pip install -U "huggingface_hub[cli]"

from huggingface_hub import HfApi

api=HfApi()

!huggingface_cli login

from huggingface_hub import login
login()  # Enter your WRITE-enabled token when prompted

!pip install -U huggingface_hub

from huggingface_hub import HfApi

api = HfApi()
api.upload_large_folder(
    folder_path="/content/drive/MyDrive/mmpose",
    repo_id="mary75/spine-deformity-detector",
    repo_type="space",

)

from huggingface_hub import create_repo

create_repo(
    repo_id="mary75/spine-deformity-detectorr",
    repo_type="space",
    space_sdk="gradio",  # Required for Spaces
    exist_ok=True,       # Skip if already exists
    private=False        # Must be public for free accounts
)

from huggingface_hub import HfApi

api = HfApi()
api.upload_large_folder(
    folder_path="/content/drive/MyDrive/mmpose",
    repo_id="mary75/spine-deformity-detectorr",
    repo_type="space",space_sdk

)